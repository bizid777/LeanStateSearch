// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file state_search/v1/state_search.proto (package state_search.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Timestamp } from "@bufbuild/protobuf";

/**
 * A theorem from Mathlib
 *
 * @generated from message state_search.v1.Theorem
 */
export class Theorem extends Message<Theorem> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: string code = 3;
   */
  code = "";

  /**
   * @generated from field: string rev = 4;
   */
  rev = "";

  /**
   * @generated from field: string module = 5;
   */
  module = "";

  constructor(data?: PartialMessage<Theorem>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.Theorem";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "rev", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "module", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Theorem {
    return new Theorem().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Theorem {
    return new Theorem().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Theorem {
    return new Theorem().fromJsonString(jsonString, options);
  }

  static equals(a: Theorem | PlainMessage<Theorem> | undefined, b: Theorem | PlainMessage<Theorem> | undefined): boolean {
    return proto3.util.equals(Theorem, a, b);
  }
}

/**
 * @generated from message state_search.v1.SearchTheoremRequest
 */
export class SearchTheoremRequest extends Message<SearchTheoremRequest> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * @generated from field: int32 nresult = 2;
   */
  nresult = 0;

  /**
   * @generated from field: bool rerank = 3;
   */
  rerank = false;

  /**
   * @generated from field: string rev = 4;
   */
  rev = "";

  constructor(data?: PartialMessage<SearchTheoremRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.SearchTheoremRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nresult", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "rerank", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "rev", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchTheoremRequest {
    return new SearchTheoremRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchTheoremRequest {
    return new SearchTheoremRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchTheoremRequest {
    return new SearchTheoremRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SearchTheoremRequest | PlainMessage<SearchTheoremRequest> | undefined, b: SearchTheoremRequest | PlainMessage<SearchTheoremRequest> | undefined): boolean {
    return proto3.util.equals(SearchTheoremRequest, a, b);
  }
}

/**
 * @generated from message state_search.v1.SearchTheoremResponse
 */
export class SearchTheoremResponse extends Message<SearchTheoremResponse> {
  /**
   * @generated from field: repeated state_search.v1.Theorem results = 1;
   */
  results: Theorem[] = [];

  constructor(data?: PartialMessage<SearchTheoremResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.SearchTheoremResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "results", kind: "message", T: Theorem, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SearchTheoremResponse {
    return new SearchTheoremResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SearchTheoremResponse {
    return new SearchTheoremResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SearchTheoremResponse {
    return new SearchTheoremResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SearchTheoremResponse | PlainMessage<SearchTheoremResponse> | undefined, b: SearchTheoremResponse | PlainMessage<SearchTheoremResponse> | undefined): boolean {
    return proto3.util.equals(SearchTheoremResponse, a, b);
  }
}

/**
 * @generated from message state_search.v1.FeedbackRequest
 */
export class FeedbackRequest extends Message<FeedbackRequest> {
  /**
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * @generated from field: string theorem_id = 2;
   */
  theoremId = "";

  /**
   * @generated from field: bool relevant = 3;
   */
  relevant = false;

  /**
   * @generated from field: bool update = 4;
   */
  update = false;

  constructor(data?: PartialMessage<FeedbackRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.FeedbackRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "theorem_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "relevant", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 4, name: "update", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeedbackRequest {
    return new FeedbackRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeedbackRequest {
    return new FeedbackRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeedbackRequest {
    return new FeedbackRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FeedbackRequest | PlainMessage<FeedbackRequest> | undefined, b: FeedbackRequest | PlainMessage<FeedbackRequest> | undefined): boolean {
    return proto3.util.equals(FeedbackRequest, a, b);
  }
}

/**
 * @generated from message state_search.v1.FeedbackResponse
 */
export class FeedbackResponse extends Message<FeedbackResponse> {
  /**
   * @generated from field: google.protobuf.Timestamp update_time = 1;
   */
  updateTime?: Timestamp;

  constructor(data?: PartialMessage<FeedbackResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "state_search.v1.FeedbackResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "update_time", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FeedbackResponse {
    return new FeedbackResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FeedbackResponse {
    return new FeedbackResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FeedbackResponse {
    return new FeedbackResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FeedbackResponse | PlainMessage<FeedbackResponse> | undefined, b: FeedbackResponse | PlainMessage<FeedbackResponse> | undefined): boolean {
    return proto3.util.equals(FeedbackResponse, a, b);
  }
}

